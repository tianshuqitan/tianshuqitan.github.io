<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.76" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <title>一、 性能优化 (Performance Optimization) | Mr.Chen</title><meta name="description" content="沧海一粟">
    <link rel="preload" href="/assets/style-BlCvd1fh.css" as="style"><link rel="stylesheet" href="/assets/style-BlCvd1fh.css">
    <link rel="modulepreload" href="/assets/app-C8vJPQwd.js"><link rel="modulepreload" href="/assets/Interview_Sample.html-CjlEduRO.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-CULBbg8V.js" as="script"><link rel="prefetch" href="/assets/index.html-OEAu5V-V.js" as="script"><link rel="prefetch" href="/assets/index.html-DPPOW4V3.js" as="script"><link rel="prefetch" href="/assets/AssetBundle.html-DLrqItci.js" as="script"><link rel="prefetch" href="/assets/index.html-B_le-D4Y.js" as="script"><link rel="prefetch" href="/assets/index.html-C9GAKQe4.js" as="script"><link rel="prefetch" href="/assets/AI.html-pt9Vf-5-.js" as="script"><link rel="prefetch" href="/assets/index.html-C41vU8vP.js" as="script"><link rel="prefetch" href="/assets/文生图.html-DGTIwjqK.js" as="script"><link rel="prefetch" href="/assets/Android.html-D4n2msl2.js" as="script"><link rel="prefetch" href="/assets/Cocos.html-Dem5D7Ko.js" as="script"><link rel="prefetch" href="/assets/Opengl.html-C6uN08no.js" as="script"><link rel="prefetch" href="/assets/index.html-BffXyArb.js" as="script"><link rel="prefetch" href="/assets/Unity.html-BOM2ku3g.js" as="script"><link rel="prefetch" href="/assets/Unreal.html-CvDZ1-jr.js" as="script"><link rel="prefetch" href="/assets/CSharp.html-DUcobgr6.js" as="script"><link rel="prefetch" href="/assets/Go.html-CrqkGSYL.js" as="script"><link rel="prefetch" href="/assets/Lua.html-BRRI0RcH.js" as="script"><link rel="prefetch" href="/assets/Python.html-VqMIEkE2.js" as="script"><link rel="prefetch" href="/assets/index.html-Bi5LK3z5.js" as="script"><link rel="prefetch" href="/assets/Rust.html-CGrXod36.js" as="script"><link rel="prefetch" href="/assets/Daily.html-YJxWkksh.js" as="script"><link rel="prefetch" href="/assets/Github.html-CX0PCcnD.js" as="script"><link rel="prefetch" href="/assets/index.html-Dw80Ije3.js" as="script"><link rel="prefetch" href="/assets/Software.html-BzdJk1-8.js" as="script"><link rel="prefetch" href="/assets/Sublime.html-CpPY9dJw.js" as="script"><link rel="prefetch" href="/assets/Programme.html-Bh8TyuOk.js" as="script"><link rel="prefetch" href="/assets/index.html-DUE0lemc.js" as="script"><link rel="prefetch" href="/assets/index.html-C9Y73JjG.js" as="script"><link rel="prefetch" href="/assets/index.html-CXg_OwRZ.js" as="script"><link rel="prefetch" href="/assets/Interview_Sample2.html-D9UNI94z.js" as="script"><link rel="prefetch" href="/assets/Interview_Sample3.html-DYgszG5i.js" as="script"><link rel="prefetch" href="/assets/Interview_Sample4.html-y5ue4aYP.js" as="script"><link rel="prefetch" href="/assets/Interview_Sample5.html-BQmYTcx3.js" as="script"><link rel="prefetch" href="/assets/index.html-BaV050ZZ.js" as="script"><link rel="prefetch" href="/assets/index.html-BEJn8KTA.js" as="script"><link rel="prefetch" href="/assets/Unity 中的内存.html-CrQ8Phse.js" as="script"><link rel="prefetch" href="/assets/index.html-Dv0cCpfz.js" as="script"><link rel="prefetch" href="/assets/DrawCall 优化.html-CWkFP7lh.js" as="script"><link rel="prefetch" href="/assets/GPU 实例化.html-CDYCz2sc.js" as="script"><link rel="prefetch" href="/assets/index.html-CHnw1Vrc.js" as="script"><link rel="prefetch" href="/assets/SRP Batcher 加速渲染性能.html-CqP-v3T4.js" as="script"><link rel="prefetch" href="/assets/Unity UI 优化.html-DhTzTpwt.js" as="script"><link rel="prefetch" href="/assets/Unity UI 优化建议.html-ViAukqyp.js" as="script"><link rel="prefetch" href="/assets/Unity 中的内存管理.html-BIn70uLs.js" as="script"><link rel="prefetch" href="/assets/Unity 中的图形优化.html-DO4EGsxw.js" as="script"><link rel="prefetch" href="/assets/了解 Unity 中的优化.html-ClJfCZ36.js" as="script"><link rel="prefetch" href="/assets/垃圾回收.html-CRdvoHgT.js" as="script"><link rel="prefetch" href="/assets/手动合并网格.html-nH1aRlhY.js" as="script"><link rel="prefetch" href="/assets/程序集.html-CUnRnie1.js" as="script"><link rel="prefetch" href="/assets/index.html-D5gDU2IT.js" as="script"><link rel="prefetch" href="/assets/Unity 技术全景图.html-DzxzykLs.js" as="script"><link rel="prefetch" href="/assets/游戏开发路线图.html-B0J9OR0y.js" as="script"><link rel="prefetch" href="/assets/Config.html-BfiTzpsh.js" as="script"><link rel="prefetch" href="/assets/Deployment.html-Dm0u556u.js" as="script"><link rel="prefetch" href="/assets/Install.html-Bes3IqHL.js" as="script"><link rel="prefetch" href="/assets/index.html-_lXNWRRg.js" as="script"><link rel="prefetch" href="/assets/ThemeHope.html-BOMNAWiz.js" as="script"><link rel="prefetch" href="/assets/index.html-PwPN32d3.js" as="script"><link rel="prefetch" href="/assets/SourceCode_List.html-CJyvaUJn.js" as="script"><link rel="prefetch" href="/assets/C_ 技术要点.html-D4BuRZjL.js" as="script"><link rel="prefetch" href="/assets/index.html-DsZgWT4H.js" as="script"><link rel="prefetch" href="/assets/数据表与程序.html-Cg7vGHBP.js" as="script"><link rel="prefetch" href="/assets/用户界面.html-FpzX3nk8.js" as="script"><link rel="prefetch" href="/assets/软件架构.html-BGe4uBzo.js" as="script"><link rel="prefetch" href="/assets/index.html-B38Q9riN.js" as="script"><link rel="prefetch" href="/assets/揭秘 Unity 的黑盒世界_高川.html-pVeX3-Mn.js" as="script"><link rel="prefetch" href="/assets/浅谈 Unity 内存管理_高川.html-BsFLsNS4.js" as="script"><link rel="prefetch" href="/assets/404.html-CNku-upk.js" as="script"><link rel="prefetch" href="/assets/index.html-vRRZgoe1.js" as="script"><link rel="prefetch" href="/assets/index.html-DcJGCB5_.js" as="script"><link rel="prefetch" href="/assets/index.html-TVR3uTNs.js" as="script"><link rel="prefetch" href="/assets/index.html-DJz6PlH9.js" as="script"><link rel="prefetch" href="/assets/index.html-dG9NMMVD.js" as="script"><link rel="prefetch" href="/assets/index.html-CLeeiJF7.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-DXWKOczD.js" as="script"><link rel="prefetch" href="/assets/SearchResult-BQzlBoNG.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/" aria-label="带我回家"><!----><!----><span class="vp-site-name">Mr.Chen</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="主页" iconsizing="height"><!--[--><i class="vp-icon fas fa-house" sizing="height"></i><!--]-->主页<!----></a></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Unity"><!--[--><!---->Unity<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link route-link-active auto-link" href="/Unity/" aria-label="Unity" iconsizing="both"><!---->Unity<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/Unity/RoadMap/" aria-label="路线图" iconsizing="both"><!---->路线图<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/Unity/Manual/" aria-label="手册" iconsizing="both"><!---->手册<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/Unity/Notes/" aria-label="笔记" iconsizing="both"><!---->笔记<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/Unity/Optimization/" aria-label="优化" iconsizing="both"><!---->优化<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><div class="vp-dropdown-wrapper"><button type="button" class="vp-dropdown-title" aria-label="Vue"><!--[--><!---->Vue<!--]--><span class="arrow"></span><ul class="vp-dropdown"><li class="vp-dropdown-item"><a class="route-link auto-link" href="/Vue/" aria-label="Vue" iconsizing="both"><!---->Vue<!----></a></li><li class="vp-dropdown-item"><a class="route-link auto-link" href="/Vue/Vuepress/" aria-label="Vuepress" iconsizing="both"><!---->Vuepress<!----></a></li></ul></button></div></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/Bookmarks/" aria-label="书签" iconsizing="height"><!---->书签<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/Language/" aria-label="编程语言" iconsizing="height"><!---->编程语言<!----></a></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!----><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="slimsearch-button" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="slimsearch-placeholder">搜索</div><div class="slimsearch-key-hints"><kbd class="slimsearch-key">Ctrl</kbd><kbd class="slimsearch-key">K</kbd></div></button><!--]--><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/Unity/" aria-label="Unity" iconsizing="both"><!---->Unity<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/Unity/RoadMap/" aria-label="路线图" iconsizing="both"><!---->路线图<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/Unity/Manual/" aria-label="手册" iconsizing="both"><!---->手册<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/Unity/Notes/" aria-label="笔记" iconsizing="both"><!---->笔记<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/Unity/Optimization/" aria-label="优化" iconsizing="both"><!---->优化<!----></a></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->一、 性能优化 (Performance Optimization)</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><span class="page-author-item">Mr.Chen</span></span><span property="author" content="Mr.Chen"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2025年10月27日</span><meta property="datePublished" content="2025-10-27T16:13:28.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 15 分钟</span><meta property="timeRequired" content="PT15M"></span><!----><!----></div><hr></div><!----><div class="" vp-content><!----><div id="markdown-content"><p>面试 Unity 高级游戏客户端开发，面试官会期望你不仅精通 Unity 的各项功能，更在<strong>软件架构、性能优化、底层原理、和团队协作</strong>方面有深入的理解和实践经验。</p><p>以下是一些可能遇到的高级面试题，分为几大类，并附上了答案要点。</p><hr><h1 id="一、-性能优化-performance-optimization" tabindex="-1"><a class="header-anchor" href="#一、-性能优化-performance-optimization"><span>一、 性能优化 (Performance Optimization)</span></a></h1><p>这是高级开发的<strong>核心</strong>。面试官会着重考察你定位和解决性能问题的能力。</p><h2 id="q1-如果游戏出现卡顿-掉帧-你的分析和解决思路是什么" tabindex="-1"><a class="header-anchor" href="#q1-如果游戏出现卡顿-掉帧-你的分析和解决思路是什么"><span>Q1: 如果游戏出现卡顿(掉帧)，你的分析和解决思路是什么？</span></a></h2><p><strong>答案要点:</strong></p><p>这是一个开放性问题，考察你的分析流程。</p><ol><li><p><strong>定位问题：</strong></p><ul><li>首先，使用 <strong>Unity Profiler</strong> 进行分析。</li><li><strong>CPU Usage</strong> 视图：查看是 CPU 卡顿还是 GPU 卡顿。</li><li><strong>CPU 瓶颈：</strong> 看 <code>Update()</code>、<code>FixedUpdate()</code>、<code>LateUpdate()</code> 中哪个函数占用高。 <ul><li><strong><code>Update()</code> (游戏逻辑):</strong> 检查是否有复杂的算法、过多的 <code>GetComponent</code>、<code>FindObjectOfType</code>、<code>SendMessage</code> 等。</li><li><strong><code>FixedUpdate()</code> (物理):</strong> 检查 <code>Physics.Update</code> 占用是否过高，是否物理交互体过多，或者 Mesh Collider 过于复杂。</li><li><strong><code>Render.RenderLoop</code> (渲染提交):</strong> 如果这里高，可能是 CPU 在准备数据给 GPU 时（例如 Culling、SetPass Calls）遇到了瓶颈。</li><li><strong>GC (垃圾回收):</strong> 检查 <code>GC.Alloc</code> 是否频繁。如果高，说明有大量临时内存分配，导致 GC 卡顿。</li></ul></li><li><strong>GPU 瓶颈：</strong><ul><li>使用 <strong>Profiler</strong> 的 <strong>GPU Usage</strong> 模块（或使用平台专用工具如 <strong>Frame Debugger</strong>, <strong>RenderDoc</strong>, <strong>Xcode Frame Debugger</strong>）。</li><li>查看 <strong>Draw Calls</strong> (现在称为 <code>SetPass Calls</code>) 是否过多。</li><li>查看 <strong>Overdraw</strong> (过度绘制) 是否严重，尤其是在 UI 和粒子特效上。</li><li>查看 <strong>Fragment Shader</strong> (片元着色器) 是否过于复杂，纹理采样是否过多。</li></ul></li></ul></li><li><p><strong>解决问题 (根据定位)：</strong></p><ul><li><strong>CPU - 游戏逻辑:</strong><ul><li><strong>缓存组件：</strong> 在 <code>Awake()</code> 中缓存 <code>GetComponent</code> 的结果。</li><li><strong>对象池 (Object Pooling):</strong> 对频繁创建和销毁的对象（如子弹、特效）使用对象池，避免 <code>Instantiate</code> 和 <code>Destroy</code> 带来的 CPU 开销和 GC。</li><li><strong>算法优化：</strong> 优化循环、使用更高效的数据结构。</li></ul></li><li><strong>CPU - 物理:</strong><ul><li>简化 <code>Mesh Collider</code>，尽量使用 <code>Primitive Collider</code> (Box, Sphere)。</li><li>调整 <strong>Physics Time Step</strong> (时间步长)。</li><li>优化物理检测（如 <code>Raycast</code>）的频率和层级 (LayerMask)。</li></ul></li><li><strong>CPU - 渲染提交 (Draw Calls):</strong><ul><li><strong>合批 (Batching):</strong><ul><li><strong>Static Batching:</strong> 对静态物体勾选 <code>Static</code>。</li><li><strong>Dynamic Batching:</strong> 对使用相同材质的小型动态物体（Unity 自动处理）。</li><li><strong>GPU Instancing:</strong> 绘制大量相同 Mesh（如草、树）。</li><li><strong>SRP Batcher (URP/HDRP):</strong> 确保材质兼容 SRP Batcher。</li></ul></li><li><strong>图集 (Atlas):</strong> 将多个纹理合并到一张大图上，使物体能共享材质，从而进行合批。</li></ul></li><li><strong>GPU - Overdraw / Fillrate:</strong><ul><li>优化 UI：避免大面积透明 UI 重叠，使用 <code>RectMask2D</code>。</li><li>优化粒子：减少粒子数量，使用更简单的 Shader，减小透明贴图面积。</li><li><strong>Shader：</strong> 优化 Shader，将复杂的计算从 Fragment Shader 移到 Vertex Shader。</li></ul></li><li><strong>GC (垃圾回收):</strong><ul><li><strong>避免堆分配 (Heap Allocation):</strong><ul><li>不要在 <code>Update</code> 中 <code>new</code> 对象。</li><li>避免在循环中进行字符串拼接 (使用 <code>StringBuilder</code>)。</li><li>缓存 <code>yield return new WaitForSeconds(t)</code> 对象。</li><li>使用非分配的物理 API (如 <code>Physics.RaycastNonAlloc</code>)。</li></ul></li><li><strong>Structs:</strong> 对小型数据结构使用 <code>struct</code> 代替 <code>class</code>。</li></ul></li></ul></li></ol><h2 id="q2-unity-中的-gc-垃圾回收-是如何工作的-你如何优化-gc" tabindex="-1"><a class="header-anchor" href="#q2-unity-中的-gc-垃圾回收-是如何工作的-你如何优化-gc"><span>Q2: Unity 中的 GC（垃圾回收）是如何工作的？你如何优化 GC？</span></a></h2><p><strong>答案要点:</strong></p><ol><li><strong>工作原理:</strong> Unity 的 Mono/IL2CPP 使用<strong>Boehm GC</strong>（一种保守的垃圾回收器）或新版的<strong>SGen GC</strong>（分代 GC）。简单来说，它会定期扫描<strong>堆 (Heap)</strong> 上的内存，找出所有不再被<strong>栈 (Stack)</strong> 或静态变量引用的对象，然后释放它们。这个过程是自动的，但会暂停主线程，导致卡顿。</li><li><strong>优化 GC (核心是减少堆分配):</strong><ul><li><strong>对象池 (Object Pooling):</strong> 避免 <code>Instantiate</code> 和 <code>Destroy</code>。</li><li><strong>避免在 Update 中分配：</strong><ul><li><code>new Class()</code></li><li>字符串拼接：<code>string a = &quot;a&quot; + &quot;b&quot;;</code> (应使用 <code>StringBuilder</code>)。</li><li>Lambda 表达式和闭包：如果闭包捕获了堆上的变量，可能会产生分配。</li><li><code>foreach</code> 循环：在某些旧版 Unity 中，<code>foreach</code> 对非泛型集合（如 <code>ArrayList</code>）会产生 GC（因为装箱 Boxing）。现在对 <code>List&lt;T&gt;</code> 等是安全的。</li><li><code>gameObject.name</code> 或 <code>gameObject.tag</code>：会产生一个新的 string 副本。</li></ul></li><li><strong>使用 Structs:</strong> 对于临时数据或小型数据包，使用 <code>struct</code> 存放在栈上。</li><li><strong>缓存：</strong> 缓存 <code>WaitForSeconds</code>、数组等。</li><li><strong>增量 GC (Incremental GC):</strong> 在 Player Settings 中开启。它将 GC 的工作分摊到多个帧中执行，减少单帧的卡顿峰值，但会增加总体的 GC 开销。适用于追求平滑帧率的项目。</li></ul></li></ol><h2 id="q3-什么是-draw-call-如何减少-draw-call" tabindex="-1"><a class="header-anchor" href="#q3-什么是-draw-call-如何减少-draw-call"><span>Q3: 什么是 Draw Call？如何减少 Draw Call？</span></a></h2><p><strong>答案要点:</strong></p><ol><li><strong>定义:</strong> Draw Call (在现代 Unity 中常被称为 <code>SetPass Call</code>) 是 CPU 向 GPU 发送的一个 &quot;绘制&quot; 命令。例如：&quot;嘿，GPU，请使用这个 Shader、这个 Material、这组 Mesh 数据来画一个东西&quot;。</li><li><strong>瓶颈:</strong> 过多的 Draw Call 会耗尽 CPU 资源（因为 CPU 需要准备数据、切换渲染状态），导致 CPU 成为瓶颈，即使 GPU 很空闲。</li><li><strong>减少方法:</strong> 核心思想是<strong>让 GPU 一次绘制更多的东西</strong>。 <ul><li><strong>合批 (Batching):</strong><ul><li><strong>Static Batching:</strong> (静态合批) 对共享相同 Material 的静态物体，在构建时将其 Mesh 合并成一个大 Mesh。缺点是增加内存占用。</li><li><strong>Dynamic Batching:</strong> (动态合批) 引擎自动对共享相同 Material 的小 Mesh（顶点数有限）动态合并。有 CPU 开销。</li></ul></li><li><strong>GPU Instancing:</strong> (GPU 实例化) 一次 Draw Call 绘制成百上千个相同的 Mesh（使用不同的位置、颜色等）。非常适合绘制草、树、石头。</li><li><strong>SRP Batcher (URP/HDRP):</strong> URP/HDRP 下的新技术。如果 Shader 兼容，它能高效地将使用不同 Material（但相同 Shader）的 Draw Call 打包。</li><li><strong>纹理图集 (Texture Atlasing):</strong> 将多个物体的纹理合并到一张大图（图集）中，这样它们就可以共享同一个 Material，从而使合批成为可能。</li></ul></li></ol><hr><h1 id="二、-架构与设计模式-architecture-design" tabindex="-1"><a class="header-anchor" href="#二、-架构与设计模式-architecture-design"><span>二、 架构与设计模式 (Architecture &amp; Design)</span></a></h1><p>高级开发需要具备搭建大型、可维护项目框架的能力。</p><h2 id="q1-你如何设计一个游戏的-ui-框架" tabindex="-1"><a class="header-anchor" href="#q1-你如何设计一个游戏的-ui-框架"><span>Q1: 你如何设计一个游戏的 UI 框架？</span></a></h2><p><strong>答案要点:</strong> 这是一个考察架构能力的开放性问题。没有标准答案，但好的答案应包含以下几点：</p><ol><li><strong>解耦 (Decoupling):</strong> 使用 <strong>MVC</strong>, <strong>MVP</strong> 或 <strong>MVVM</strong> 模式。 <ul><li><strong>View:</strong> UGUI Prefab 和挂载的脚本，只负责显示和接收输入。</li><li><strong>Presenter / ViewModel:</strong> 中间层，负责业务逻辑（如点击按钮后做什么），并连接 View 和 Model。</li><li><strong>Model:</strong> 纯数据层（如玩家数据、背包数据）。</li><li><em>目标：</em> View 和 Model 完全分离，更换 UI（View）不需要修改逻辑（Presenter）。</li></ul></li><li><strong>层级管理 (Layer Management):</strong><ul><li>需要一个 <code>UIManager</code> 来管理 UI 的显示层级。</li><li>例如：背景层 (HUD)、常规窗口层 (背包)、弹出层 (提示框)、顶层 (加载遮罩)。</li></ul></li><li><strong>窗口栈 (Window Stack):</strong><ul><li>管理窗口的打开和关闭顺序，支持 &quot;返回&quot; 操作，类似 Android 的 Activity 栈。</li></ul></li><li><strong>资源管理 (Resource Management):</strong><ul><li>UI Prefab 应通过 <strong>Addressables</strong> 或 <strong>AssetBundle</strong> 异步加载，而不是放在场景中或 Resources 文件夹。</li><li>管理 UI 的加载和卸载，避免内存占用过高。</li></ul></li><li><strong>事件系统 (Event System):</strong><ul><li>使用全局事件总线 (Event Bus)（例如基于 <code>ScriptableObject</code> 的事件或 C# <code>event</code>）来解耦 UI 系统和其他游戏系统（如玩家死亡、获得物品）的通信。</li></ul></li></ol><h2 id="q2-什么是-scriptableobject-so-你会在什么场景下使用它" tabindex="-1"><a class="header-anchor" href="#q2-什么是-scriptableobject-so-你会在什么场景下使用它"><span>Q2: 什么是 ScriptableObject (SO)？你会在什么场景下使用它？</span></a></h2><p><strong>答案要点:</strong></p><ol><li><strong>定义:</strong> <code>ScriptableObject</code> 是 Unity 中一种可以<strong>创建实例并保存为项目资产 (.asset)</strong> 的数据容器。它继承自 <code>UnityEngine.Object</code> 但不依附于 <code>GameObject</code>。</li><li><strong>使用场景 (核心价值：数据与逻辑分离):</strong><ul><li><strong>游戏配置数据:</strong> 存储不常变化的数据，如武器配置、敌人属性、关卡数据。设计师可以直接在 Project 窗口修改这些 <code>.asset</code> 文件，而不需要动场景或 Prefab。</li><li><strong>共享数据:</strong> 多个 MonoBehaviour 可以引用同一个 SO 实例。例如，一个 <code>PlayerStats</code> SO 可以在多个场景中被引用，作为共享的玩家数据（注意：运行时修改 SO 会直接修改.asset 文件，通常只用于读取配置）。</li><li><strong>创建&quot;事件&quot;资产 (Event Channel):</strong> 可以创建一个 <code>GameEvent</code> 类型的 SO，游戏中的物体 A 可以 &quot;Raise&quot; 这个事件，物体 B 可以 &quot;Listen&quot; 这个事件。A 和 B 互不知道对方，完全解耦。</li><li><strong>插件或系统的配置:</strong> 很多插件（如 URP 的 Render Pipeline Asset）本身就是一个 SO，用于存储复杂的配置。</li></ul></li></ol><h2 id="q3-谈谈你对-ecs-dots-的理解-它解决了什么问题" tabindex="-1"><a class="header-anchor" href="#q3-谈谈你对-ecs-dots-的理解-它解决了什么问题"><span>Q3: 谈谈你对 ECS (DOTS) 的理解？它解决了什么问题？</span></a></h2><p><strong>答案要点:</strong></p><ol><li><strong>ECS (Entity Component System) 是什么:</strong> 是一种<strong>面向数据 (Data-Oriented)</strong> 的编程范式，与 Unity 传统的面向对象 (Object-Oriented, <code>GameObject-Component</code>) 相对。 <ul><li><strong>Entity (实体):</strong> 一个 ID，一个&quot;空壳&quot;。</li><li><strong>Component (组件):</strong> <em>纯数据</em>，通常是 <code>struct</code> (如 <code>Position</code>, <code>Velocity</code>)。没有方法。</li><li><strong>System (系统):</strong> <em>纯逻辑</em>，负责处理具有特定组件组合的 Entities（如 <code>MovementSystem</code> 负责更新所有带 <code>Position</code> 和 <code>Velocity</code> 的实体）。</li></ul></li><li><strong>解决了什么问题 (核心：性能):</strong><ul><li><strong>CPU 缓存命中率 (Cache Locality):</strong> 传统 OOP 中，<code>GameObject</code> 在内存中是分散的。ECS 会将同类数据（如所有的 <code>Position</code>）连续存储在内存块 (Archetype Chunks) 中。</li><li><strong>数据访问：</strong> CPU 访问连续内存（如遍历一个 <code>Position</code> 数组）远快于访问分散内存（遍历 <code>GameObject</code> 列表，再逐个 <code>GetComponent&lt;Transform&gt;().position</code>）。</li><li><strong>多线程 (C# Job System):</strong> 由于数据和逻辑分离，且数据布局规整，ECS 非常适合与 C# Job System 结合，轻松实现大规模并行计算（如上万个单位的移动），充分利用现代 CPU 的多核。</li></ul></li></ol><hr><h1 id="三、-unity-引擎与-c-engine-c" tabindex="-1"><a class="header-anchor" href="#三、-unity-引擎与-c-engine-c"><span>三、 Unity 引擎与 C# (Engine &amp; C#)</span></a></h1><p>考察对 Unity 工作流和 C#高级特性的理解。</p><h2 id="q1-unity-的-c-脚本后端-mono-和-il2cpp-有什么区别" tabindex="-1"><a class="header-anchor" href="#q1-unity-的-c-脚本后端-mono-和-il2cpp-有什么区别"><span>Q1: Unity 的 C# 脚本后端 Mono 和 IL2CPP 有什么区别？</span></a></h2><p><strong>答案要点:</strong></p><ol><li><strong>Mono:</strong><ul><li>使用 <strong>JIT (Just-In-Time) 编译</strong>（在 PC 等平台）或 <strong>AOT (Ahead-of-Time) 编译</strong>（在 iOS 等平台）。</li><li>它将 C#代码编译为 .NET 中间语言 (IL)。运行时，Mono 的虚拟机 (runtime) 负责执行这些 IL 代码。</li><li><em>优点：</em> 编辑器下编译快。</li><li><em>缺点：</em> 运行效率通常低于 IL2CPP，且在某些平台（如 iOS、主机）受限制（必须 AOT）。</li></ul></li><li><strong>IL2CPP (Intermediate Language To C++):</strong><ul><li>Unity 的自研技术。它分两步： <ol><li>将 .NET IL 代码转换为 C++ 代码。</li><li>使用目标平台的原生 C++编译器（如 Clang, MSVC）将 C++代码编译为本地机器码。</li></ol></li><li><em>优点：</em><ul><li><strong>高性能：</strong> C++编译优化后，通常比 Mono 运行更快。</li><li><strong>跨平台：</strong> 支持所有平台，是 iOS 和主机的唯一选择。</li><li><strong>代码安全：</strong> C++代码更难被反编译。</li></ul></li><li><em>缺点：</em> 编译时间（尤其是 C++编译阶段）比 Mono 长。</li></ul></li></ol><h2 id="q2-什么是值类型-value-type-和引用类型-reference-type-struct-和-class-的区别" tabindex="-1"><a class="header-anchor" href="#q2-什么是值类型-value-type-和引用类型-reference-type-struct-和-class-的区别"><span>Q2: 什么是值类型 (Value Type) 和引用类型 (Reference Type)？<code>struct</code> 和 <code>class</code> 的区别？</span></a></h2><p><strong>答案要点:</strong></p><ol><li><p><strong>值类型 (Value Type):</strong></p><ul><li>如 <code>int</code>, <code>float</code>, <code>bool</code>, <code>Vector3</code>, 以及自定义的 <code>struct</code>。</li><li><strong>存储：</strong> 变量本身直接存储数据。通常（但不总是）分配在<strong>栈 (Stack)</strong> 上。</li><li><strong>传递：</strong> 按值传递。当赋值或作为参数传递时，会<strong>复制</strong>一份完整的数据。</li></ul></li><li><p><strong>引用类型 (Reference Type):</strong></p><ul><li>如 <code>string</code>, <code>Array</code>, <code>List&lt;T&gt;</code>, 以及自定义的 <code>class</code> (包括所有 <code>MonoBehaviour</code>)。</li><li><strong>存储：</strong> 变量存储的是一个指向数据实际位置的<strong>引用（地址）</strong>。数据本身存储在<strong>堆 (Heap)</strong> 上。</li><li><strong>传递：</strong> 按引用传递（技术上是按值传递引用）。当赋值或传递时，只复制引用（地址），它们指向堆上同一份数据。</li></ul></li><li><p><strong>高级应用 (面试官想听的):</strong></p><ul><li><strong>性能：</strong> <code>struct</code> 可以避免 GC，因为它们通常在栈上。但如果 <code>struct</code> 过大，按值复制的开销（<code>memcpy</code>）可能会高于传递一个引用。</li><li><strong>装箱 (Boxing):</strong> 将值类型（如 <code>int</code>）转换为引用类型（如 <code>object</code>）的过程。例如 <code>object o = 10;</code>。这会在堆上分配内存并产生 GC，应在性能敏感代码中避免。</li><li><strong><code>struct</code> vs <code>class</code> 的选择：</strong> 当数据结构很小（如 <code>Vector3</code>）、逻辑简单、且希望按值复制时，使用 <code>struct</code>。其他情况（如 <code>MonoBehaviour</code>、需要继承、需要复杂逻辑）使用 <code>class</code>。</li></ul></li></ol><h2 id="q3-unity-中的协程-coroutine-和-c-的-async-await-有什么区别" tabindex="-1"><a class="header-anchor" href="#q3-unity-中的协程-coroutine-和-c-的-async-await-有什么区别"><span>Q3: Unity 中的协程 (Coroutine) 和 C# 的 <code>async/await</code> 有什么区别？</span></a></h2><p><strong>答案要点:</strong></p><ol><li><strong>协程 (Coroutine):</strong><ul><li><strong>本质：</strong> Unity 实现的<strong>迭代器 (Iterator)</strong> 模式。<code>yield return</code> 会保存当前函数的执行状态，并在下一帧（或指定时间后）从该点继续。</li><li><strong>线程：</strong> 始终运行在<strong>主线程</strong>上。它只是将任务分片到不同的帧，<em>不是多线程</em>。</li><li><strong>用途：</strong> 非常适合处理游戏中的时间相关逻辑（如 &quot;等待 2 秒后执行&quot;、&quot;播放动画时等待&quot;）。</li><li><strong>缺点：</strong> 依赖 <code>MonoBehaviour</code> (必须由它启动)，代码嵌套（回调地狱）时可读性差。</li></ul></li><li><strong><code>async/await</code> (Task):</strong><ul><li><strong>本质：</strong> C# 语言层面的<strong>异步编程模型 (TAP)</strong>。</li><li><strong>线程：</strong> <code>async</code> 方法开始时在当前线程（通常是主线程）。当 <code>await</code> 一个 <em>可以</em> 在后台运行的任务时（如 <code>Task.Run()</code>、<code>HttpClient.GetStringAsync()</code>），它会释放主线程，让主线程继续工作。任务完成后，<code>await</code> 后续的代码会（默认）<strong>切回主线程</strong>继续执行。</li><li><strong>用途：</strong> 非常适合处理 I/O 操作（如网络请求、读写文件），或将 CPU 密集型计算（使用 <code>Task.Run</code>）抛到<strong>线程池</strong>中执行，避免阻塞主线程。</li><li><strong>总结：</strong> 协程用于<strong>主线程的时间分片</strong>。<code>async/await</code> 用于<strong>真正的异步/并发</strong>，处理 I/O 或利用多核。</li></ul></li></ol><hr><h1 id="四、-图形与渲染-graphics-rendering" tabindex="-1"><a class="header-anchor" href="#四、-图形与渲染-graphics-rendering"><span>四、 图形与渲染 (Graphics &amp; Rendering)</span></a></h1><p>高级开发需要理解渲染管线，并能与 TA（技术美术）协作。</p><h2 id="q1-解释一下-urp-universal-render-pipeline-和内置管线-built-in-的主要区别。" tabindex="-1"><a class="header-anchor" href="#q1-解释一下-urp-universal-render-pipeline-和内置管线-built-in-的主要区别。"><span>Q1: 解释一下 URP (Universal Render Pipeline) 和内置管线 (Built-in) 的主要区别。</span></a></h2><p><strong>答案要点:</strong></p><ol><li><strong>内置管线 (Built-in):</strong><ul><li>Unity 的传统管线。</li><li><strong>特点：</strong> &quot;黑盒&quot;，定制性差。渲染路径主要是前向渲染 (Forward Rendering) 和延迟渲染 (Deferred Rendering)。</li><li><strong>缺点：</strong> 扩展困难，性能优化（如合批）依赖旧技术。</li></ul></li><li><strong>URP (Universal Render Pipeline):</strong><ul><li><strong>可编程渲染管线 (SRP)</strong> 的一种。</li><li><strong>特点：</strong><ul><li><strong>可定制：</strong> 通过 C#脚本（<code>Renderer Features</code>）可以轻松注入自定义的渲染通道。</li><li><strong>性能/跨平台：</strong> 专为移动端到 PC 端的全平台优化。</li><li><strong>渲染：</strong> 主要使用<strong>单通道前向渲染 (Single-Pass Forward Rendering)</strong>，在 VR 中效率很高。</li><li><strong>工具：</strong> 深度集成了 <strong>Shader Graph</strong> 和 <strong>VFX Graph</strong>。</li><li><strong>SRP Batcher：</strong> 提供了更高效的合批机制。</li></ul></li></ul></li></ol><h2 id="q2-什么是-shader-vertex-shader-顶点着色器-和-fragment-shader-片元-像素着色器-分别做什么" tabindex="-1"><a class="header-anchor" href="#q2-什么是-shader-vertex-shader-顶点着色器-和-fragment-shader-片元-像素着色器-分别做什么"><span>Q2: 什么是 Shader？Vertex Shader (顶点着色器) 和 Fragment Shader (片元/像素着色器) 分别做什么？</span></a></h2><p><strong>答案要点:</strong></p><ol><li><strong>Shader:</strong> 是一段运行在 <strong>GPU</strong> 上的小程序。它告诉 GPU 如何获取 Mesh 数据（顶点、UV、法线等）并最终将其渲染到屏幕上的像素。</li><li><strong>Vertex Shader (顶点着色器):</strong><ul><li><strong>输入：</strong> 模型的单个<strong>顶点</strong>数据（如模型空间坐标、UV、法线）。</li><li><strong>运行：</strong> 模型的<em>每个顶点</em>都会运行一次。</li><li><strong>核心工作：</strong> <strong>坐标变换</strong>。将顶点坐标从模型空间 (Model Space) 转换到世界空间 (World Space)，再到视图空间 (View Space)，最后到裁剪空间 (Clip Space)。</li><li><strong>其他：</strong> 也可以处理顶点动画，并将 UV、法线等数据传递给片元着色器。</li></ul></li><li><strong>Fragment (Pixel) Shader (片元/像素着色器):</strong><ul><li><strong>输入：</strong> 从 Vertex Shader 传递过来的插值数据（如 UV、世界法线）和光栅化后确定的<strong>屏幕像素位置</strong>。</li><li><strong>运行：</strong> 模型覆盖到的<em>每个屏幕像素</em>都会运行一次。</li><li><strong>核心工作：</strong> <strong>计算颜色</strong>。根据 UV 坐标采样纹理，结合法线和光照信息，计算该像素的最终颜色 (Color)。</li><li><strong>性能：</strong> Fragment Shader 通常是 GPU 的瓶颈，因为屏幕像素远多于模型顶点。复杂的计算（如多重纹理采样、复杂光照）应尽量避免。</li></ul></li></ol><hr><h1 id="五、-软技能与经验-problem-solving-soft-skills" tabindex="-1"><a class="header-anchor" href="#五、-软技能与经验-problem-solving-soft-skills"><span>五、 软技能与经验 (Problem Solving &amp; Soft Skills)</span></a></h1><h2 id="q1-你在项目中遇到的最困难的技术挑战是什么-你是如何解决的" tabindex="-1"><a class="header-anchor" href="#q1-你在项目中遇到的最困难的技术挑战是什么-你是如何解决的"><span>Q1: 你在项目中遇到的最困难的技术挑战是什么？你是如何解决的？</span></a></h2><p><strong>答案要点:</strong> 这是考察你解决实际问题能力和经验深度的。你需要准备一个真实、具体、有深度的例子。</p><ul><li><strong>STAR 法则:</strong><ul><li><strong>S (Situation):</strong> 项目背景是什么？（例如：一个百人同屏的 MMO 项目）</li><li><strong>T (Task):</strong> 遇到的具体技术难题是什么？（例如：同屏人数一多，帧率暴跌至 10 帧）</li><li><strong>A (Action):</strong> 你采取了哪些<strong>具体行动</strong>？（例如：使用 Profiler 定位到是<code>Animator.Update</code>和 Draw Calls 过高 -&gt; 我设计了一套 LOD（细节层次）系统，远处的玩家关闭 Animator，并使用烘焙的静态 Mesh -&gt; 同时与 TA 合作，将所有玩家的装备合并材质，使用图集和 GPU Instancing -&gt; ...）</li><li><strong>R (Result):</strong> 结果如何？（例如：帧率稳定在 30 帧，同屏承载能力从 30 人提升到 100 人）。</li></ul></li></ul><h2 id="q2-你如何进行代码审查-code-review-你关注哪些点" tabindex="-1"><a class="header-anchor" href="#q2-你如何进行代码审查-code-review-你关注哪些点"><span>Q2: 你如何进行代码审查 (Code Review)？你关注哪些点？</span></a></h2><p><strong>答案要点:</strong></p><ol><li><strong>功能性 (Functionality):</strong> 代码是否正确实现了需求？</li><li><strong>可读性 (Readability):</strong> 命名是否规范？逻辑是否清晰？注释是否必要且准确？</li><li><strong>性能 (Performance):</strong> 是否有明显的性能陷阱？（如在 <code>Update</code> 中 <code>GetComponent</code>、产生 GC 等）。</li><li><strong>架构 (Architecture):</strong> 是否遵循了项目的设计规范？（如 MVC/MVP，是否正确使用了事件系统）。</li><li><strong>可维护性 (Maintainability):</strong> 是否有&quot;坏味道&quot;（Bad Smell）？（如超大函数、重复代码）。</li><li><strong>态度：</strong> 作为高级开发，CR 时应<strong>对事不对人</strong>，提出建设性意见，而不是批评。</li></ol><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h1><p>高级 Unity 面试 = <strong>优化深度 + 架构广度 + 底层原理 + 解决问题的经验</strong>。准备好你最得意的项目，并能清晰地阐述你在其中扮演的关键角色和技术决策。祝你面试顺利！</p></div><!----><!----><!----></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">最近更新：</span><time class="vp-meta-info" datetime="2025-10-27T16:13:28.000Z" data-allow-mismatch>2025/10/27 16:13</time></div></div></footer><!----><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><!----><div class="vp-copyright">Copyright © 2025 Mr.Chen </div></footer></div><!--]--><!--]--><!--[--><!----><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/assets/app-C8vJPQwd.js" defer></script>
  </body>
</html>
