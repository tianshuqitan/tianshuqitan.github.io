import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as e,a as l,e as i,w as o,r as s,o as c,d as p}from"./app-CFYj2sWG.js";const g={};function h(d,t){const r=s("RouteLink");return c(),a("div",null,[t[1]||(t[1]=e('<h1 id="drawcall-优化" tabindex="-1"><a class="header-anchor" href="#drawcall-优化"><span>DrawCall 优化</span></a></h1><p><a href="https://docs.unity3d.com/2022.3/Documentation/Manual/optimizing-draw-calls.html" target="_blank" rel="noopener noreferrer">原文地址 - UnityManual</a></p><p>要在屏幕上绘制几何体，Unity 会向图形 API 发出绘制调用(Draw Call)。绘制调用告诉图形 API 要绘制什么以及如何绘制。每个绘制调用包含图形 API 在屏幕上绘制所需的所有信息，例如关于纹理(Textures)、着色器(Shaders)和缓冲区(Buffers)的信息。绘制调用(Draw Call)可能很耗费资源，但通常为绘制调用所做的准备工作比绘制调用本身更耗费资源。</p><blockquote><p>绘制的一般流程为：把数据加载到显存(手机无显卡，公用内存，没这一步) -&gt; 设置渲染状态 -&gt; 调用 DrawCall。</p></blockquote><p>为了准备绘制调用，CPU 会设置资源并更改 GPU 上的内部设置。这些设置统称为渲染状态(Render State)。<strong>对渲染状态的更改（例如切换到不同的材质）是图形 API 执行的最耗费资源的操作</strong>。</p><blockquote><p>有一些优化策略，降低的不是 DrawCall 的次数，减少的是设置渲染状态的消耗。</p></blockquote><p>由于渲染状态更改很耗费资源，因此优化它们非常重要。优化渲染状态更改的主要方法是减少它们的数量。有两种方法可以做到这一点：</p><ul><li>减少绘制调用的总数。当您减少绘制调用的数量时，您也减少了它们之间的渲染状态更改的数量。</li><li>以减少渲染状态更改数量的方式组织绘制调用。如果图形 API 可以使用相同的渲染状态执行多个绘制调用，则可以将绘制调用分组在一起，而不需要执行那么多渲染状态更改。</li></ul><p>优化绘制调用和渲染状态更改对您的应用程序有许多好处。主要是它提高了帧时间，但它还：</p><ul><li>减少应用程序所需的电量。对于电池供电的设备，这会降低电池耗尽的速度。它还减少了设备在运行您的应用程序时产生的热量。</li><li>提高应用程序未来开发的可维护性。当您尽早优化绘制调用和渲染状态更改并将其保持在优化水平时，您可以向场景添加更多 GameObject 而不会产生大的性能开销。</li></ul><p>您可以在 Unity 中使用多种方法来优化和减少绘制调用和渲染状态更改。某些方法更适合某些场景。Unity 中可用的方法如下：</p><ul><li><a href="#gpu-instancing">GPU instancing</a>: 同时渲染同一网格的多个副本。GPU 实例化对于绘制在场景中多次出现的几何体（例如树木或灌木）很有用。</li><li><a href="#drawcall-%E6%89%B9%E5%A4%84%E7%90%86">DrawCall 批处理</a>：组合网格以减少绘制调用。Unity 提供以下类型的内置 DrawCall 批处理： <ul><li><a href="#%E9%9D%99%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86">静态批处理</a>：预先组合 <a href="https://docs.unity3d.com/cn/current/Manual/StaticObjects.html" target="_blank" rel="noopener noreferrer">static</a> GameObject 的网格。Unity 将组合数据发送到 GPU，但单独渲染组合中的每个网格。Unity 仍然可以单独剔除网格，但每个绘制调用的资源密集度较低，因为数据的状态永远不会改变。</li><li><a href="#%E5%8A%A8%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86">动态批处理</a>：在 CPU 上变换网格顶点，将共享相同配置的顶点分组，并在一个绘制调用中渲染它们。如果顶点存储相同数量和类型的属性，则它们共享相同的配置。例如，<code>position</code> 和 <code>normal</code>。</li></ul></li><li><a href="#%E6%89%8B%E5%8A%A8%E5%90%88%E5%B9%B6%E7%BD%91%E6%A0%BC">手动合并网格</a>：使用 <a href="https://docs.unity3d.com/cn/current/ScriptReference/Mesh.CombineMeshes.html" target="_blank" rel="noopener noreferrer">Mesh.CombineMeshes</a> 函数手动将多个网格组合成一个网格。Unity 在单个绘制调用中渲染组合的网格，而不是每个网格一个绘制调用。</li><li><a href="#srp-batcher">SRP Batcher</a>：如果您的项目使用可编程渲染管线 (SRP)，请使用 SRP Batcher 减少 Unity 准备和分派使用相同着色器变体的材质的绘制调用所需的 CPU 时间。</li></ul><p><strong>优先级</strong></p><p>您可以在同一场景中使用多种绘制调用优化方法，但请注意 Unity 会按特定顺序优先考虑绘制调用优化方法。如果您将 GameObject 标记为使用多个绘制调用优化方法，Unity 会使用优先级最高的方法。唯一的例外是 <a href="#srp-batcher">SRP Batcher</a>。当您使用 SRP Batcher 时，Unity 还支持对与 SRP Batcher 兼容的 GameObjects 进行静态批处理。Unity 按以下顺序优先考虑绘制调用优化：</p><ol><li>SRP Batcher 和静态批处理</li><li>GPU instancing</li><li>动态批处理</li></ol><p>如果您将 GameObject 标记为静态批处理并且 Unity 成功批处理它，Unity 会禁用该 GameObject 的 GPU instancing，即使渲染器使用实例化着色器也是如此。发生这种情况时，Inspector 窗口会显示一条警告消息，建议您禁用静态批处理。同样，如果 Unity 可以对网格使用 GPU instancing，Unity 会禁用该网格的动态批处理。</p><h2 id="gpu-实例化" tabindex="-1"><a class="header-anchor" href="#gpu-实例化"><span>GPU 实例化</span></a></h2>',17)),l("p",null,[i(r,{to:"/Unity/Optimization/GPU%20%E5%AE%9E%E4%BE%8B%E5%8C%96.html"},{default:o(()=>t[0]||(t[0]=[p("GPU 实例化")])),_:1})]),t[2]||(t[2]=e('<h2 id="drawcall-批处理" tabindex="-1"><a class="header-anchor" href="#drawcall-批处理"><span>DrawCall 批处理</span></a></h2><p>DrawCall 批处理(Draw call batching)是一种 DrawCall 优化方法，它组合网格以便 Unity 可以用更少的绘制调用渲染它们。Unity 提供两种内置的DrawCall 批处理方法：</p><ul><li><a href="#%E9%9D%99%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86">静态批处理</a>: 对于 <a href="https://docs.unity3d.com/cn/current/Manual/StaticObjects.html" target="_blank" rel="noopener noreferrer">static</a> GameObject，Unity 将它们组合在一起并一起渲染。</li><li><a href="#%E5%8A%A8%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86">动态批处理</a>: 对于足够小的网格，这会在 CPU 上变换它们的顶点，将相似的顶点分组在一起，并在一个绘制调用中渲染它们。</li></ul><p>Unity 的内置DrawCall 批处理比手动合并网格有几个优点；最值得注意的是，Unity 仍然可以单独剔除网格。但是，它也有一些缺点；<strong>静态批处理会产生内存和存储开销</strong>，而<strong>动态批处理会产生一些 CPU 开销</strong>。</p><p><strong>要求和兼容性</strong></p><p>本节包含有关 Unity 内置DrawCall 批处理方法的渲染管线兼容性的信息。</p><p>渲染管线兼容性</p><table><thead><tr><th style="text-align:left;"><strong>功能</strong></th><th style="text-align:left;"><strong>内置渲染管线</strong></th><th style="text-align:left;"><strong>通用渲染管线(URP)</strong></th><th style="text-align:left;"><strong>高清渲染管线(HDRP)</strong></th><th style="text-align:left;"><strong>自定义可编程渲染管线(SRP)</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Static Batching</strong></td><td style="text-align:left;">是</td><td style="text-align:left;">是</td><td style="text-align:left;">是</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;"><strong>Dynamic Batching</strong></td><td style="text-align:left;">是</td><td style="text-align:left;">是</td><td style="text-align:left;">否</td><td style="text-align:left;">是</td></tr></tbody></table><p><strong>使用 DrawCall 批处理</strong></p><p>以下使用信息与静态和动态批处理都相关。有关每种 DrawCall 批处理方法的特定信息，例如如何启用和使用每种方法，请参阅 <a href="#%E9%9D%99%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86">静态批处理</a> 和 <a href="#%E5%8A%A8%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86">动态批处理</a>。</p><p><a href="https://docs.unity3d.com/cn/current/Manual/class-MeshRenderer.html" target="_blank" rel="noopener noreferrer">Mesh Renderer</a>、<a href="https://docs.unity3d.com/cn/current/Manual/class-TrailRenderer.html" target="_blank" rel="noopener noreferrer">Trail Renderers</a>、<a href="https://docs.unity3d.com/cn/current/Manual/class-LineRenderer.html" target="_blank" rel="noopener noreferrer">Line Renderers</a>、<a href="https://docs.unity3d.com/cn/current/Manual/class-ParticleSystem.html" target="_blank" rel="noopener noreferrer">Particle Systems</a> 和 <a href="https://docs.unity3d.com/cn/current/Manual/class-SpriteRenderer.html" target="_blank" rel="noopener noreferrer">Sprite Renderers</a> 支持 DrawCall 批处理。其他类型的渲染组件（包括 Skinned Mesh Renderers Cloth）不受支持。Unity 仅将相同类型的渲染器与其他渲染器批处理在一起；例如，Mesh Renderers 与 Mesh Renderers。</p><p>Unity <strong>批处理使用相同材质的 GameObject 的绘制调用</strong>。这意味着要从 DrawCall 批处理中获得最佳结果，请在<strong>尽可能多的 GameObject 之间共享材质</strong>。如果您有两个材质资源除了它们的纹理之外完全相同，您可以将纹理组合成一个更大的单一纹理。此过程称为纹理图集。有关更多信息，请参阅关于纹理图集的 <a href="http://en.wikipedia.org/wiki/Texture_atlas" target="_blank" rel="noopener noreferrer">Wikipedia article</a>。当纹理位于同一图集中时，您可以使用单个材质资源。</p><p>在 Built-in Render Pipeline 中，您可以使用 <a href="https://docs.unity3d.com/cn/current/ScriptReference/MaterialPropertyBlock.html" target="_blank" rel="noopener noreferrer">MaterialPropertyBlock</a> 更改材质属性而不会破坏 DrawCall 批处理。CPU 仍然需要进行一些渲染状态更改，但使用 <code>MaterialPropertyBlock</code> 比使用多个材质更快。如果您的项目使用 Scriptable Render Pipeline，请不要使用 <code>MaterialPropertyBlock</code>，因为它们会移除材质的 SRP Batcher 兼容性。</p><p>透明着色器通常要求 Unity 以从后到前的顺序渲染网格。为了批处理透明网格，Unity 首先将它们从后到前排序，然后尝试批处理它们。由于 Unity 必须从后到前渲染网格，因此它通常无法像不透明网格那样批处理那么多透明网格。</p><p>Unity 无法对 Transform 组件中包含镜像的 GameObject 应用动态批处理。例如，如果一个 GameObject 的比例为 1，而另一个 GameObject 的比例为 –1，Unity 无法将它们批处理在一起。</p><p>如果您无法使用 DrawCall 批处理，手动组合彼此靠近的网格可能是一个很好的替代方案。有关组合网格的更多信息，请参阅 <a href="#%E6%89%8B%E5%8A%A8%E5%90%88%E5%B9%B6%E7%BD%91%E6%A0%BC">手动合并网格</a>。</p><p><strong>警告</strong>：当您从 C# 脚本访问共享材质属性时，请确保使用 <a href="https://docs.unity3d.com/cn/current/ScriptReference/Renderer-sharedMaterial.html" target="_blank" rel="noopener noreferrer">Renderer.sharedMaterial</a> 而不是 <a href="https://docs.unity3d.com/cn/current/ScriptReference/Renderer-material.html" target="_blank" rel="noopener noreferrer">Renderer.material</a>。<code>Renderer.material</code> 创建材质的副本并将副本分配回渲染器。这会阻止 Unity 批处理该渲染器的绘制调用。</p><h3 id="静态批处理" tabindex="-1"><a class="header-anchor" href="#静态批处理"><span>静态批处理</span></a></h3><p>静态批处理是一种 <a href="#drawcall-%E6%89%B9%E5%A4%84%E7%90%86draw-call-batching">DrawCall 批处理</a> 方法，它组合不移动的网格以减少 DrawCall。它将组合的网格变换到世界空间并为它们构建一个共享的顶点和索引缓冲区。然后，对于可见的网格，Unity 执行一系列简单的绘制调用，每个调用之间几乎没有状态更改。<strong>静态批处理不会减少绘制调用的数量，而是减少它们之间的渲染状态更改的数量</strong>。</p><p>静态批处理比 <a href="#%E5%8A%A8%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86">动态批处理</a> 更高效，因为静态批处理不会在 CPU 上变换顶点。有关静态批处理的性能影响的更多信息，请参阅 <a href="https://docs.unity3d.com/cn/current/Manual/static-batching.html#performance-implications" target="_blank" rel="noopener noreferrer">Performance implications</a>。</p><p><strong>渲染管线兼容性</strong></p><table><thead><tr><th style="text-align:left;"><strong>功能</strong></th><th style="text-align:left;"><strong>内置渲染管线</strong></th><th style="text-align:left;"><strong>通用渲染管线 (URP)</strong></th><th style="text-align:left;"><strong>高清渲染管线 (HDRP)</strong></th><th style="text-align:left;"><strong>自定义可编程渲染管线(SRP)</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Static Batching</strong></td><td style="text-align:left;">是</td><td style="text-align:left;">是</td><td style="text-align:left;">是</td><td style="text-align:left;">是</td></tr></tbody></table><p><strong>使用静态批处理</strong></p><p>Unity 可以在构建时和运行时执行静态批处理。作为一般规则，如果 GameObject 在构建应用程序之前存在于场景中，请使用 <a href="https://docs.unity3d.com/cn/current/Manual/static-batching.html#editor" target="_blank" rel="noopener noreferrer">Editor</a> 在构建时批处理您的 GameObject。如果您在运行时创建 GameObject 及其网格，请使用 <a href="https://docs.unity3d.com/cn/current/Manual/static-batching.html#runtime" target="_blank" rel="noopener noreferrer">Runtime API</a>。</p><p>当您使用运行时 API 时，您可以更改静态批处理根的变换属性。这意味着您可以移动、旋转或缩放构成静态批处理的整个网格组合。您不能更改单个网格的变换属性。</p><p>要对一组 GameObject 使用静态批处理，GameObject 必须符合静态批处理的条件。除了 [使用 DrawCall 批处理] 中描述的标准外，请确保：</p><ul><li>GameObject 处于活动状态。</li><li>GameObject 具有 <a href="https://docs.unity3d.com/cn/current/Manual/class-MeshFilter.html" target="_blank" rel="noopener noreferrer">Mesh Filter</a> 组件，并且该组件已启用。</li><li>Mesh Filter 组件引用了 <a href="https://docs.unity3d.com/cn/current/Manual/class-Mesh.html" target="_blank" rel="noopener noreferrer">Mesh</a>。</li><li>网格启用了读/写。</li><li>网格的顶点数大于 0。</li><li>网格尚未与其他网格组合。</li><li>GameObject 具有 <a href="https://docs.unity3d.com/cn/current/Manual/class-MeshRenderer.html" target="_blank" rel="noopener noreferrer">Mesh Renderer</a> 组件，并且该组件已启用。</li><li>Mesh Renderer 组件不使用任何着色器将 <code>DisableBatching</code> 标签设置为 true 的材质。</li><li>您想要批处理在一起的网格使用相同的顶点属性。例如，Unity 可以批处理使用顶点位置、顶点法线和一个 UV 的网格，但不能批处理使用顶点位置、顶点法线、UV0、UV1 和顶点切线的网格。</li></ul><p>有关静态批处理的性能影响的信息，请参阅 [性能影响]。</p><p><strong>构建时的静态批处理</strong></p><p>您可以在 Editor 中启用构建时的静态批处理。</p><p>要在构建时执行静态批处理：</p><ol><li>转到 <strong>Edit</strong> &gt; <strong>Project Settings</strong> &gt; <strong>Player</strong>。</li><li>在 <strong>Other Settings</strong> 中，启用 <strong>Static Batching</strong>。</li><li>在 Scene 视图或 Hierarchy 中，选择要批处理的 GameObject 并在 Inspector 中查看它。 <strong>提示</strong>：您可以同时选择多个 GameObject 以对所有它们启用静态批处理。</li><li>在 GameObject 的 <a href="https://docs.unity3d.com/cn/current/Manual/StaticObjects.html" target="_blank" rel="noopener noreferrer">Static Editor Flags</a> 中，启用 <strong>Batching Static</strong>。</li></ol><p>如果静态网格满足 [使用 DrawCall 批处理] 中描述的标准，Unity 会自动将指定的静态网格批处理到同一绘制调用中。</p><p><img src="https://docs.unity3d.com/cn/current/uploads/Main/StaticTagInspector.png" alt=""></p><blockquote><p>Inspector 中 GameObject 的 Static Editor Flags 复选框。</p></blockquote><p><strong>注意</strong>：如果您在构建时执行静态批处理，Unity 在运行时不会使用任何 CPU 资源来生成静态批处理的网格数据。</p><p><strong>运行时的静态批处理</strong></p><p>要在运行时批处理静态网格，Unity 提供了 <a href="https://docs.unity3d.com/cn/current/ScriptReference/StaticBatchingUtility.html" target="_blank" rel="noopener noreferrer">StaticBatchingUtility</a> 类。静态 <a href="https://docs.unity3d.com/cn/current/ScriptReference/StaticBatchingUtility.Combine.html" target="_blank" rel="noopener noreferrer">StaticBatchingUtility.Combine</a> 方法组合您传入的 GameObject 并准备它们进行静态批处理。这对于您在运行时以程序方式生成的网格特别有用。</p><p>与构建时的静态批处理不同，运行时的批处理不需要您启用 <strong>Static Batching</strong> Player 设置。有关如何使用此 API 的信息，请参阅 <a href="https://docs.unity3d.com/cn/current/ScriptReference/StaticBatchingUtility.html" target="_blank" rel="noopener noreferrer">StaticBatchingUtility</a>。</p><p><strong>性能影响</strong></p><p>使用静态批处理需要额外的 CPU 内存来存储组合的几何体。如果多个 GameObject 使用相同的网格，<strong>Unity 会为每个 GameObject 创建网格的副本</strong>，并将每个副本插入组合的网格中。这意味着相同的几何体在组合的网格中多次出现。无论您使用 <a href="https://docs.unity3d.com/cn/current/Manual/static-batching.html#editor" target="_blank" rel="noopener noreferrer">Editor</a> 还是 <a href="https://docs.unity3d.com/cn/current/Manual/static-batching.html#runtime" target="_blank" rel="noopener noreferrer">Runtime API</a> 准备 GameObject 进行静态批处理，Unity 都会这样做。如果您希望保持较小的内存占用，您可能不得不牺牲渲染性能并避免对某些 GameObject 进行静态批处理。例如，在密集的森林环境中将树木标记为静态可能会对内存产生严重影响。</p><p><strong>注意</strong>：静态批处理可以包含的顶点数量有限制。每个静态批处理最多可以包含 <code>64000</code> 个顶点。如果有更多，Unity 会创建另一个批处理。</p><h3 id="动态批处理" tabindex="-1"><a class="header-anchor" href="#动态批处理"><span>动态批处理</span></a></h3><p>动态批处理是一种 <a href="#drawcall-%E6%89%B9%E5%A4%84%E7%90%86draw-call-batching">DrawCall 批处理</a> 方法，它批处理移动的 GameObject 以减少 DrawCall。动态批处理在网格和 Unity 在运行时动态生成的几何体（例如 <a href="https://docs.unity3d.com/cn/current/Manual/class-ParticleSystem.html" target="_blank" rel="noopener noreferrer">Particle Systems</a>）之间的工作方式不同。有关网格和动态生成的几何体之间的内部差异的信息，请参阅 [网格的动态批处理] 和 [动态生成的几何体的动态批处理]。</p><p><strong>注意</strong>：网格的动态批处理旨在优化旧低端设备的性能。在现代消费级硬件上，<strong>动态批处理在 CPU 上所做的工作可能比绘制调用的开销更大</strong>。这会对性能产生负面影响。有关更多信息，请参阅 [网格的动态批处理]。</p><p><strong>渲染管线兼容性</strong></p><table><thead><tr><th style="text-align:left;"><strong>功能</strong></th><th style="text-align:left;"><strong>内置渲染管线</strong></th><th style="text-align:left;"><strong>通用渲染管线 (URP)</strong></th><th style="text-align:left;"><strong>高清渲染管线 (HDRP)</strong></th><th style="text-align:left;"><strong>自定义可编程渲染管线(SRP)</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Dynamic Batching</strong></td><td style="text-align:left;">是</td><td style="text-align:left;">是</td><td style="text-align:left;">否</td><td style="text-align:left;">是</td></tr></tbody></table><p><strong>使用动态批处理</strong></p><p>Unity 始终对动态几何体（如 Particle Systems）使用动态批处理。</p><p>要对网格使用动态批处理：</p><ol><li>转到 <strong>Edit</strong> &gt; <strong>Project Settings</strong> &gt; <strong>Player</strong>。</li><li>在 <strong>Other Settings</strong> 中，启用 <strong>Dynamic Batching</strong>。</li></ol><p>如果移动的网格满足 [使用 DrawCall 批处理] 中描述的标准，Unity 会自动将它们批处理到同一绘制调用中。</p><p><strong>网格的动态批处理</strong></p><p>网格的动态批处理通过<strong>在 CPU 上</strong>而不是 GPU 上变换所有顶点来工作。这意味着动态批处理只有在变换工作比执行绘制调用更不耗费资源时才是一种优化。</p><p>绘制调用的资源需求取决于许多因素，主要是图形 API。例如，在主机或现代 API（如 Apple Metal）上，绘制调用的开销通常要低得多，而且动态批处理通常不会带来性能提升。要确定在您的应用程序中使用动态批处理是否有益，请 <a href="https://docs.unity3d.com/cn/current/Manual/Profiler.html" target="_blank" rel="noopener noreferrer">Profiler</a> 您的应用程序，比较启用和禁用动态批处理的情况。</p><p>Unity 可以对阴影投射器使用动态批处理，即使它们的材质不同，只要 Unity 阴影通道所需的材质值相同。例如，多个箱子可以使用具有不同纹理的材质。虽然材质资源不同，但这种差异对于阴影投射器通道无关紧要，Unity 可以在阴影渲染步骤中批处理箱子 GameObject 的阴影。</p><p><strong>限制</strong></p><p>在以下情况下，Unity 要么根本无法使用动态批处理，要么只能有限地应用动态批处理：</p><ul><li>Unity 无法对包含超过 <code>900</code> 个顶点属性和 <code>225</code> 个顶点的网格应用动态批处理。这是因为网格的动态批处理每个顶点都有开销。例如，如果您的着色器使用顶点位置、顶点法线和单个 UV，那么 Unity 最多可以批处理 <code>225</code> 个顶点。但是，如果您的着色器使用顶点位置、顶点法线、UV0、UV1 和顶点切线，那么 Unity 只能批处理 <code>180</code> 个顶点。</li><li>如果 GameObject 使用不同的材质实例，Unity 无法将它们批处理在一起，即使它们本质上是相同的。唯一的例外是阴影投射器渲染。</li><li>具有光照贴图的 GameObject 具有额外的渲染器参数。这意味着，如果您想要批处理具有光照贴图的 GameObject，它们必须指向相同的光照贴图位置。</li><li>Unity 无法完全对使用多通道着色器的 GameObject 应用动态批处理。 <ul><li>几乎所有 Unity 着色器在正向渲染中都支持多个灯光。为了实现这一点，它们为每个灯光处理一个额外的渲染通道。Unity 仅批处理第一个渲染通道。它无法批处理每个像素灯光的额外绘制调用。</li><li><a href="https://docs.unity3d.com/cn/current/Manual/RenderingPaths.html" target="_blank" rel="noopener noreferrer">Legacy Deferred rendering path</a> 不支持动态批处理，因为它以两个渲染通道绘制 GameObject。第一个通道是灯光预通道，第二个通道渲染 GameObject。</li></ul></li></ul><p><strong>动态生成的几何体的动态批处理</strong></p><p>以下渲染器动态生成几何体（例如粒子和线），您可以使用动态批处理进行优化：</p><ul><li><a href="https://docs.unity3d.com/cn/current/Manual/Built-inParticleSystem.html" target="_blank" rel="noopener noreferrer">Built-in Particle Systems</a></li><li><a href="https://docs.unity3d.com/cn/current/Manual/class-LineRenderer.html" target="_blank" rel="noopener noreferrer">Line Renderers</a></li><li><a href="https://docs.unity3d.com/cn/current/Manual/class-TrailRenderer.html" target="_blank" rel="noopener noreferrer">Trail Renderers</a></li></ul><p>动态批处理对于动态生成的几何体的工作方式与网格不同：</p><ol><li>对于每个渲染器，Unity 将所有可动态批处理的内容构建到一个大的顶点缓冲区中</li><li>渲染器为批处理设置材质状态</li><li>然后将顶点缓冲区绑定到 GPU</li><li>对于批处理中的每个渲染器，Unity 更新顶点缓冲区中的偏移量并提交新的绘制调用</li></ol><p>这种方法类似于 Unity 为 <a href="#%E9%9D%99%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86">静态批处理</a> 提交绘制调用的方式。</p><h2 id="手动合并网格" tabindex="-1"><a class="header-anchor" href="#手动合并网格"><span>手动合并网格</span></a></h2><p>您可以手动将多个网格组合成单个网格来优化 DrawCall。Unity 在单个绘制调用中渲染组合的网格，而不是每个网格一个绘制调用。在网格彼此靠近且不相对移动的情况下，此技术可以是 <a href="#drawcall-%E6%89%B9%E5%A4%84%E7%90%86draw-call-batching">DrawCall 批处理</a> 的良好替代方案。例如，对于带有许多抽屉的静态橱柜，将所有内容组合成一个网格是有意义的。</p><p><strong>警告</strong>：Unity 无法单独剔除您组合的网格。这意味着如果组合网格的一部分在屏幕上，Unity 会绘制整个组合网格。如果网格是静态的并且您希望 Unity 单独剔除它们，请改用 <a href="#%E9%9D%99%E6%80%81%E6%89%B9%E5%A4%84%E7%90%86">静态批处理</a>。</p><p>有两种主要方法可以组合网格：</p><ul><li>在创作网格时使用您的资产生成工具</li><li>在 Unity 中使用 <a href="https://docs.unity3d.com/cn/current/ScriptReference/Mesh.CombineMeshes.html" target="_blank" rel="noopener noreferrer">Mesh.CombineMeshes</a></li></ul><h2 id="srp-batcher" tabindex="-1"><a class="header-anchor" href="#srp-batcher"><span><a href="https://docs.unity3d.com/2022.3/Documentation/Manual/SRPBatcher.html" target="_blank" rel="noopener noreferrer">SRP Batcher</a></span></a></h2><p>可编程渲染管线 (SRP) 批处理是一种 DrawCall 优化，可显著提高使用 SRP 的应用程序的性能。SRP 批处理器减少了 Unity 准备和分派使用相同着色器变体的材质的绘制调用所需的 CPU 时间。</p><blockquote><p>相同 Shader(或者变体) 但是材质不相同</p></blockquote><p>可编程渲染管线 (SRP) 批处理器减少了 Unity 渲染使用相同着色器变体的许多材质的场景所需的 CPU 时间。</p><p><strong>渲染管线兼容性</strong></p><table><thead><tr><th style="text-align:left;"><strong>功能</strong></th><th style="text-align:left;"><strong>内置渲染管线</strong></th><th style="text-align:left;"><strong>通用渲染管线 (URP)</strong></th><th style="text-align:left;"><strong>高清渲染管线 (HDRP)</strong></th><th style="text-align:left;"><strong>自定义可编程渲染管线(SRP)</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>SRP Batcher</strong></td><td style="text-align:left;">否</td><td style="text-align:left;">是</td><td style="text-align:left;">是</td><td style="text-align:left;">是</td></tr></tbody></table><p><strong>GameObject 兼容性</strong></p><p>在任何给定场景中，一些 GameObject 与 SRP 批处理器兼容，而另一些则不兼容。兼容的 GameObject 使用 SRP 批处理器代码路径，不兼容的 GameObject 使用标准 SRP 代码路径。有关更多信息，请参阅 [SRP 批处理器的工作原理]。</p><p>GameObject 必须满足以下要求才能与 SRP 批处理器代码路径兼容：</p><ul><li>GameObject 必须包含网格或蒙皮网格。它不能是粒子。</li><li>GameObject 不能使用 [MaterialPropertyBlocks]。</li><li>GameObject 使用的着色器必须与 SRP 批处理器兼容。有关更多信息，请参阅 [着色器兼容性]。</li></ul><p><strong>着色器兼容性</strong></p><p>高清渲染管线 (HDRP) 和通用渲染管线 (URP) 中的所有光照和无光照着色器都符合此要求（这些着色器的粒子版本除外）。</p><p>要使自定义着色器与 SRP 批处理器兼容，它必须满足以下要求：</p><ul><li>着色器必须在名为 <code>UnityPerDraw</code> 的单个常量缓冲区中声明所有内置引擎属性。例如，<code>unity_ObjectToWorld</code> 或 <code>unity_SHAr</code>。</li><li>着色器必须在名为 <code>UnityPerMaterial</code> 的单个常量缓冲区中声明所有材质属性。</li></ul><p>您可以在 Inspector 面板中检查着色器的兼容性状态。</p><p><img src="https://docs.unity3d.com/cn/current/uploads/Main/SRP_batcher_shader_compatibility.png" alt=""></p><blockquote><p>您可以在特定着色器的 Inspector 面板中检查着色器的兼容性。</p></blockquote><p><strong>使用 SRP 批处理器</strong></p><p>本节包含有关如何在 Unity 的预构建可编程渲染管线中使用 SRP 批处理器的信息。</p><p><strong>在 URP 中使用 SRP 批处理器</strong></p><p>要在 URP 中激活 SRP 批处理器，请执行以下操作：</p><ol><li>在 Project 窗口中选择 <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@12.1/manual/universalrp-asset.html" target="_blank" rel="noopener noreferrer">URP Asset</a>。</li><li>在 URP 资源的 Inspector 中，启用 <strong>SRP Batcher</strong>。如果此选项不可见，请按照以下 [如何显示 URP 资源的其他属性] 的说明操作。</li></ol><p><strong>如何显示 URP 资源的其他属性</strong></p><p>默认情况下，Unity 不会显示 URP 资源中的某些高级属性。要查看所有可用属性：</p><ul><li><p>在 URP 资源中的任何部分，单击垂直省略号图标 (⋮) 并选择 <strong>Show Additional Properties</strong></p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/show-additional-properties.png" alt=""></p><blockquote><p>显示其他属性</p></blockquote><p>Unity 在当前部分显示所有可用属性。</p></li></ul><p>要显示所有部分中的所有其他属性：</p><ol><li><p>单击垂直省略号图标并选择 <strong>Show All Additional Properties</strong>。Unity 在 <strong>Preferences</strong> 窗口中打开 <strong>Core Render Pipeline</strong> 部分。</p></li><li><p>在属性 <strong>Additional Properties &gt; Visibility</strong> 中，选择 <strong>All Visible</strong>。</p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/show-all-additional-properties.png" alt=""></p><blockquote><p>Additional Properties &gt; Visibility &gt; All Visible</p></blockquote></li></ol><p><strong>在 HDRP 中使用 SRP 批处理器</strong></p><p>当您使用 HDRP 时，Unity 默认启用 SRP 批处理器。不建议禁用 SRP 批处理器。但是，您可以暂时禁用它以进行调试。</p><p>要使用 Editor 在构建时启用和禁用 SRP 批处理器：</p><ol><li>在 Project 窗口中选择 <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@17.2/manual/HDRP-Asset.html" target="_blank" rel="noopener noreferrer">HDRP 资源</a>。</li><li>在资源的 Inspector 中，进入 <a href="https://docs.unity3d.com/cn/current/Manual/InspectorOptions.html" target="_blank" rel="noopener noreferrer">Debug mode</a>。在 Debug 模式下，您可以看到 HDRP 资源的属性，包括 SRP Batcher 属性。</li><li>选择 <strong>Enable</strong> <strong>SRP Batcher</strong> 以启用或禁用 SRP 批处理器。</li></ol><p>要在运行时启用或禁用 SRP 批处理器，请在您的 C# 代码中切换以下全局变量：</p><div class="language-cs line-numbers-mode" data-highlighter="shiki" data-ext="cs" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">GraphicsSettings</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">useScriptableRenderPipelineBatching</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>SRP 批处理器的工作原理</strong></p><p>传统的优化绘制调用的方法是减少它们的数量。相反，<strong>SRP 批处理器减少了绘制调用之间的渲染状态更改</strong>。为此，SRP 批处理器将一系列 <code>bind</code> 和 <code>draw</code> GPU 命令组合在一起。每个命令序列称为 SRP 批处理。</p><p><img src="https://docs.unity3d.com/cn/current/uploads/Main/SROShaderPass.png" alt=""></p><blockquote><p>绑定和绘制命令的批处理减少了绘制调用之间的 GPU 设置。</p></blockquote><p>要为您的渲染实现最佳性能，每个 SRP 批处理应包含尽可能多的 <code>bind</code> 和 <code>draw</code> 命令。要实现这一点，请尽可能少地使用着色器变体。您仍然可以使用任意数量的具有相同着色器的不同材质。</p><p>当 Unity 在渲染循环期间检测到新材质时，CPU 会收集所有属性并将它们绑定到 GPU 的常量缓冲区中。GPU 缓冲区的数量取决于着色器如何声明其常量缓冲区。</p><p>SRP 批处理器是一种低级渲染循环，它使材质数据持久保存在 GPU 内存中。如果材质内容没有更改，SRP 批处理器不会进行任何渲染状态更改。相反，SRP 批处理器使用专用代码路径在大型 GPU 缓冲区中更新 Unity 引擎属性，如下所示：</p><p><img src="https://docs.unity3d.com/cn/current/uploads/Main/SRP_Batcher_loop.png" alt=""></p><blockquote><p>SRP 批处理器渲染工作流程。SRP 批处理器使用专用代码路径在大型 GPU 缓冲区中更新 Unity 引擎属性。</p></blockquote><p>在这里，CPU 仅处理标记为 <strong>Per Object large buffer</strong> 的 Unity 引擎属性。所有材质都有位于 GPU 内存中的持久常量缓冲区，随时可以使用。这加快了渲染速度，因为：</p><ul><li>所有材质内容现在都持久保存在 GPU 内存中</li><li>专用代码管理一个大型的每对象 GPU 常量缓冲区，用于所有每对象属性</li></ul><p><strong>移除 GameObject 的 SRP 批处理器兼容性</strong></p><p>在某些罕见情况下，您可能需要使特定 GameObject 与 SRP 批处理器不兼容。例如，如果您想使用 <a href="#gpu-instancing">GPU instancing</a>，它与 SRP 批处理器不兼容。如果您想使用完全相同的材质渲染许多相同的网格，GPU 实例化可能比 SRP 批处理器更高效。要使用 GPU 实例化，您必须：</p><ul><li>使用 <a href="https://docs.unity3d.com/cn/current/ScriptReference/Graphics.DrawMeshInstanced.html" target="_blank" rel="noopener noreferrer">Graphics.DrawMeshInstanced</a></li><li>手动移除 SRP 批处理器兼容性并为材质启用 GPU 实例化</li></ul><p>有两种方法可以从 GameObject 移除与 SRP 批处理器的兼容性：</p><ul><li>使着色器不兼容</li><li>使渲染器不兼容</li></ul><p><strong>提示</strong>：如果您使用 GPU 实例化而不是 SRP 批处理器，请使用 <a href="https://docs.unity3d.com/cn/current/Manual/Profiler.html" target="_blank" rel="noopener noreferrer">Profiler</a> 确保 GPU 实例化对您的应用程序比 SRP 批处理器更高效。</p><p><strong>移除着色器兼容性</strong></p><p>您可以使手写和 Shader Graph 着色器与 SRP 批处理器不兼容。但是，对于 Shader Graph 着色器，如果您经常更改和重新编译 Shader Graph，使 <a href="https://docs.unity3d.com/cn/current/Manual/SRPBatcher.html#removing-renderer-compatibility" target="_blank" rel="noopener noreferrer">renderer incompatible</a> 更简单。</p><p>要使 Unity 着色器与 SRP 批处理器不兼容，您需要对着色器源文件进行更改：</p><ol><li>对于手写着色器，打开着色器源文件。对于 Shader Graph 着色器，将 Shader Graph 的编译着色器源代码复制到新的着色器源文件中。在您的应用程序中使用新的着色器源文件而不是 Shader Graph。</li><li>在着色器的 <code>Properties</code> 块中添加一个新的 <a href="https://docs.unity3d.com/cn/current/Manual/SL-Properties.html" target="_blank" rel="noopener noreferrer">material property</a> 声明。不要在 <code>UnityPerMaterial</code> 常量缓冲区中声明新的材质属性。</li></ol><p>材质属性不需要做任何事情；只要有一个不在 <code>UnityPerMaterial</code> 常量缓冲区中的材质属性，就会使着色器与 SRP 批处理器不兼容。</p><p><strong>警告</strong>：如果您使用 Shader Graph，请注意每次编辑和重新编译 Shader Graph 时，您都必须重复此过程。</p><p><strong>移除渲染器兼容性</strong></p><p>您可以使单个渲染器与 SRP 批处理器不兼容。为此，请向渲染器添加 <code>MaterialPropertyBlock</code>。</p><p><strong>在 Unity Frame Debugger 中分析 SRP 批处理器</strong></p><p>您可以在 <a href="https://docs.unity3d.com/cn/current/Manual/FrameDebugger.html" target="_blank" rel="noopener noreferrer">Frame Debugger</a> 窗口中检查 SRP 批处理的状态。每个 SRP 批处理显示 Unity 使用了多少绘制调用，Unity 附加到着色器的关键字，以及 Unity 没有将该绘制调用与前一个批处理在一起的原因。</p><p>要检查 SRP 批处理器批处理的状态，请执行以下操作：</p><ol><li>在 Editor 中，打开 Frame Debugger（菜单：<strong>Window</strong> &gt; <strong>Analysis</strong> &gt; <strong>Frame Debugger</strong>）。</li><li>在 Frame Debugger 中，转到 <strong>Render Camera</strong> &gt; <strong>Render Opaques</strong>。</li><li>展开 <strong>RenderLoopNewBatcher.Draw</strong> 列表。</li><li>选择要检查的 <strong>SRP Batch</strong>。</li></ol><p>在下面的示例中，原因是：<strong>Nodes have different shaders</strong>。这意味着该 SRP 批处理的着色器与前一个 SRP 批处理的着色器不同。因为 SRP 批处理器使用了不同的着色器，所以它创建了一个新的批处理。如果多个 SRP 批处理的绘制调用数量较少，通常意味着项目使用了太多的着色器变体。</p><p><img src="https://docs.unity3d.com/cn/current/uploads/Main/SRP_Batcher_batch_information.png" alt=""></p><blockquote><p>在 Frame Debugger 窗口中，您可以找到有关单个 SRP 批处理的详细信息，包括为什么 SRP 批处理器创建新的 SRP 批处理而不是继续现有的批处理。</p></blockquote><p>如果您编写自己的可编程渲染管线，而不是使用通用渲染管线或高清渲染管线，请尝试编写一个通用的多用途着色器，关键字数量最少。这是最优的，因为您可以使用任意数量的材质属性。</p>',136))])}const y=n(g,[["render",h]]),P=JSON.parse('{"path":"/Unity/Optimization/DrawCall%20%E4%BC%98%E5%8C%96.html","title":"DrawCall 优化","lang":"zh-CN","frontmatter":{"source":"https://docs.unity3d.com/2022.3/Documentation/Manual/optimizing-draw-calls.html","article":false,"index":false},"git":{"createdTime":1744972326000,"updatedTime":1747391455000,"contributors":[{"name":"unknown","username":"unknown","email":"chenmengjie@cyou-inc.com","commits":3,"url":"https://github.com/unknown"},{"name":"chenjie","username":"chenjie","email":"1587272470@qq.com","commits":2,"url":"https://github.com/chenjie"}]},"readingTime":{"minutes":24.69,"words":7406},"filePathRelative":"Unity/Optimization/DrawCall 优化.md","localizedDate":"2025年4月18日","excerpt":""}');export{y as comp,P as data};
