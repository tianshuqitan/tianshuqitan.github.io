import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as l,b as e,a as i,d as a,e as p,w as h,r as k,o as r}from"./app-DW6sG65O.js";const d="/assets/UI_ImageInspector-DjAjyqSE.png",A="/assets/screen_space_camera-BHj58LpU.png",o="/assets/world_space_camera_2-DP19zr2h.png",y="/assets/squeeze_Unity25-CVkYm9zg.png",B={};function g(c,s){const n=k("RouteLink");return r(),l("div",null,[s[5]||(s[5]=e('<h1 id="unity-ui-优化建议" tabindex="-1"><a class="header-anchor" href="#unity-ui-优化建议"><span>Unity UI 优化建议</span></a></h1><p><a href="https://create.unity.com/Unity-UI-optimization-tips" target="_blank" rel="noopener noreferrer">原文地址 - UnityLearn</a></p><p>本文汇集了提升 Unity UI 性能的最佳实践技巧。更多详细内容可参考 Unity 工程师 Ian Dundore 的精彩演讲 <a href="https://www.youtube.com/watch?v=_wxitgdx-UI&amp;list=PLX2vGYjWbI0Rzo8D-vUCFVb_hHGxXWd9j&amp;index=8" target="_blank" rel="noopener noreferrer">Squeezing Unity: Tips for raising performance</a>（UI 优化部分从 23:38 开始）。</p><h2 id="合理划分-canvas" tabindex="-1"><a class="header-anchor" href="#合理划分-canvas"><span>合理划分 Canvas</span></a></h2><p><strong>问题：当 UI Canvas 上的元素发生变化时，会导致整个 Canvas 重新计算。</strong></p><p><a href="https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/UICanvas.html" target="_blank" rel="noopener noreferrer">Canvas</a> 是 Unity UI 的基础组件。它生成代表 UI 元素的网格(Mesh)，当 UI 元素变化时需要重新生成网格(Mesh)，并向 GPU 发出绘制调用以显示 UI。</p><p>网格(Mesh)生成可能很耗性能。需要批量处理 UI 元素以减少绘制调用次数(Draw Call)。由于批量生成(Batch Generation)很昂贵，我们希望只在必要时才重新生成。问题是，当 Canvas 上的元素发生变化时，整个 Canvas 都需要重新分析以确定如何最优绘制其元素。</p><p>许多用户在一个 Canvas 中构建整个游戏的 UI，包含数千个元素。因此当他们改变一个元素时，可能会导致 CPU 峰值消耗数毫秒（关于为什么重建很昂贵，可参考 Ian 演讲中 24:55 处的内容）。</p><p><strong>解决方案：合理划分 Canvas。</strong></p><p>每个 Canvas 都是一个孤岛，将其上的元素与其他 Canvas 隔离。因此，划分 Canvas 是解决 Unity UI 批处理问题的主要方法。</p><p>你也可以嵌套 Canvas，这样设计师可以创建大型层级化 UI 而无需考虑多个 Canvas 之间的屏幕位置关系。子 Canvas 也会将其内容与父 Canvas 和兄弟 Canvas 隔离。它们维护自己的几何体并执行自己的批处理。</p><p>当使用子 Canvas 划分时，尝试根据更新频率对元素进行分组。例如，将动态元素与静态元素分开（在 29:36 处，Ian 提供了一个很好的 Canvas 智能划分示例）。</p><h2 id="graphic-raycaster-的最佳使用" tabindex="-1"><a class="header-anchor" href="#graphic-raycaster-的最佳使用"><span>Graphic Raycaster 的最佳使用</span></a></h2><p><strong>问题：Graphic Raycaster 的最佳使用方式</strong></p><p><a href="https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/script-GraphicRaycaster.html" target="_blank" rel="noopener noreferrer">Graphic Raycaster</a> 是将输入转换为 UI 事件的组件。它将屏幕/触摸输入转换为事件，然后发送给感兴趣的 UI 元素。每个需要输入的 Canvas（包括子 Canvas）都需要一个 Graphic Raycaster。</p><p>尽管名字叫 Raycaster，但 Graphic Raycaster 实际上并不进行射线检测：默认情况下，它只测试 UI 图形。它获取 Canvas 上所有对输入感兴趣的 UI 元素集合，并执行相交检查：检查输入事件发生点是否与每个 UI 元素的 RectTransform 相交，且该元素被标记为可交互。</p><p>挑战在于并非所有 UI 元素都需要接收更新。</p><p><strong>解决方案：关闭静态或非交互元素的 Raycast Target。</strong></p><p>例如按钮上的文本。关闭 Raycast Target 将直接减少 Graphic Raycaster 每帧需要执行的相交检查次数。</p><p><img src="'+d+'" alt=""></p><p><strong>问题：在某些情况下，Graphic Raycaster 确实会进行射线检测。</strong></p><p>如果将 Canvas 的 Render Mode 设置为 Worldspace Camera 或 Screen Space Camera，你还可以设置一个 blocking mask。blocking mask 决定 Raycaster 是否会通过 2D 或 3D 物理系统投射射线，以判断是否有物理对象阻挡用户与 UI 的交互。</p><p><strong>解决方案：通过 2D 或 3D 物理系统投射射线可能很昂贵，应谨慎使用此功能。</strong></p><p>此外，通过不为非交互式 UI Canvas 添加 Graphic Raycaster 来最小化其数量，因为在这种情况下没有理由检查交互事件。</p><h2 id="避免使用-camera-main" tabindex="-1"><a class="header-anchor" href="#避免使用-camera-main"><span>避免使用 Camera.main</span></a></h2><p><strong>问题：World Space Canvas 需要知道交互事件应该来自哪个相机。</strong></p><p>当设置 Canvas 以 World Space 或 Screen Space 渲染时，可以指定用于为 UI 的 Graphic Raycaster 生成交互事件的 Camera。这个设置对于 <code>Screen Space - Camera</code> Canvas 是必需的，称为 <code>Render Camera</code>。</p><p><img src="'+A+'" alt=""></p><p>然而，对于 <code>World Space</code> Canvas 这个设置是可选的，称为 <code>Event Camera</code>。</p><p><img src="'+o+'" alt=""></p><p>如果在 World Space Canvas 上留空 Event Camera 字段，并不意味着你的 Canvas 不会接收事件。相反，它会使用游戏的主 Camera。 为了确定哪个 Camera 是主 Camera，它会访问 <code>Camera.main</code> 属性。</p><p><img src="'+y+`" alt=""></p><p>根据 Unity 采用的代码路径，每个 Graphic Raycaster、每个 World Space Canvas 每帧会访问 Camera.main 7-10 次。而 Camera.main 每次被访问时都会调用 Object.FindObjectWithTag！显然，这在运行时不是好事。</p><p><strong>解决方案：避免使用 Camera.main。</strong></p><p>缓存 Camera 引用，并创建一个系统来跟踪主相机。如果使用 World Space Canvas，总是分配一个 Event Camera。不要留空这个设置！如果 Event Camera 需要改变，编写代码来更新 Event Camera 属性。</p><h2 id="尽可能避免使用-layout-group" tabindex="-1"><a class="header-anchor" href="#尽可能避免使用-layout-group"><span>尽可能避免使用 Layout Group</span></a></h2><p><strong>问题：每个试图标记其 Layout 为脏的 UI 元素至少会执行一次 GetComponents 调用。</strong></p><p>当布局系统中的子元素发生变化时，布局系统会被标记为脏。变化的子元素会使拥有它的 Layout System 失效。</p><p>关于 Layout System：Layout System 是一组连续的 Layout Group，它们直接位于 Layout Element 之上。Layout Element 不仅仅是 Layout Element 组件：UI 图像、文本和 Scroll Rect 也都是 Layout Element。而且，Scroll Rect 也是 Layout Group。</p><p>回到问题：每个标记其布局为脏的 UI 元素至少会执行一次 GetComponents 调用。这个调用会在 Layout Element 的父对象上寻找有效的 Layout Group。如果找到一个，它会继续沿着 Transform 层级向上查找，直到找不到 Layout Group 或到达层级根节点。因此，每个 Layout Group 都会为每个子 Layout Element 的脏标记过程增加一个 GetComponents 调用，使得嵌套的 Layout Group 对性能极为不利。</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// LayoutElement.cs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">protected</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> SetDirty</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">IsActive</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">())</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    LayoutRebuilder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">MarkLayoutForRebuild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">transform</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> as </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RectTransform</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// LayoutRebuilder.cs</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MarkLayoutForRebuild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RectTransform</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> rect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">rect</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ||</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> rect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">gameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> comps</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> ListPool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Component</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    bool</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> validLayoutGroup</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    RectTransform</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> layoutRoot</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> rect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> parent</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> layoutRoot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> as </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RectTransform</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">validLayoutGroup</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">parent</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ||</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">gameObject</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        validLayoutGroup</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GetComponents</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">typeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ILayoutGroup</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">), </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">comps</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        </span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> comps</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            var</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> cur</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> comps</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">];</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">cur</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> cur</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> is </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Behaviour</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ((</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Behaviour</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">cur</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">isActiveAndEnabled</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">                validLayoutGroup</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">                layoutRoot</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">                break</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        parent</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> as </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">RectTransform</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // We know the layout root is valid if it&#39;s not the same as the rect,</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // since we checked that above. But if they&#39;re the same we still need to check.</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">layoutRoot</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> ==</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> rect</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> !</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">ValidController</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">layoutRoot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">comps</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">        ListPool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Component</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Release</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">comps</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    </span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    MarkLayoutRootForRebuild</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">layoutRoot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    ListPool</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Component</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Release</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">comps</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>解决方案：尽可能避免使用 Layout Group。</strong></p><p>使用锚点进行比例布局。对于元素数量动态变化的热门 UI，考虑编写自己的布局计算代码，并确保只在需要时使用，而不是在每次变化时都使用。</p><h2 id="正确使用-ui-对象缓存池" tabindex="-1"><a class="header-anchor" href="#正确使用-ui-对象缓存池"><span>正确使用 UI 对象缓存池</span></a></h2><p><strong>问题：以错误的方式使用 UI 对象缓存池。</strong></p><p>通常，人们通过重新设置父对象然后禁用使 UI 对象回到对象池，但这会导致不必要的脏标记。</p><p><strong>解决方案：先禁用对象，然后将其重新设置父对象添加到缓存池中。</strong></p><p>你会脏标记旧层级一次，但当你重新设置父对象时，可以避免第二次脏标记旧层级，而且根本不会脏标记新层级。如果要从池中取出对象，先重新设置父对象，然后更新数据，最后启用它。</p><h2 id="如何隐藏-canvas" tabindex="-1"><a class="header-anchor" href="#如何隐藏-canvas"><span>如何隐藏 Canvas</span></a></h2><p><strong>问题：如何隐藏 Canvas</strong></p><p>有时你想隐藏一些 UI 元素和 Canvas。如何最高效地做到这一点？</p><p><strong>解决方案：禁用 Canvas 组件本身</strong></p><p>禁用 Canvas 组件将停止 Canvas 向 GPU 发出绘制调用，因此 Canvas 将不再可见。然而，Canvas 不会丢弃其顶点缓冲区；它会保留所有网格和顶点，当你重新启用它时，不会触发重建，只会重新开始绘制它们。</p><p>此外，禁用 Canvas 组件不会在 Canvas 层级上触发昂贵的 OnDisable/OnEnable 回调。只需小心禁用运行昂贵每帧代码的子组件。</p><h2 id="在-ui-元素上优化使用-animator" tabindex="-1"><a class="header-anchor" href="#在-ui-元素上优化使用-animator"><span>在 UI 元素上优化使用 Animator</span></a></h2><p><strong>问题：在 UI 上使用 Animator</strong></p><p>Animator 每帧都会脏标记其元素，即使动画中的值没有变化。Animator 没有无操作检查。</p><p><strong>解决方案：</strong></p><p>只在总是变化的动态元素上使用 Animator。对于很少变化或只在事件响应中短时间变化的元素，编写自己的代码或补间系统。</p><h2 id="更多资源" tabindex="-1"><a class="header-anchor" href="#更多资源"><span>更多资源</span></a></h2>`,60)),i("ul",null,[s[1]||(s[1]=i("li",null,[i("a",{href:"https://www.youtube.com/watch?v=_wxitgdx-UI&list=PLX2vGYjWbI0Rzo8D-vUCFVb_hHGxXWd9j&index=8",target:"_blank",rel:"noopener noreferrer"},"Squeezing Unity: Tips for raising performance"),a("（UI 优化部分从 23:38 开始）。")],-1)),i("li",null,[p(n,{to:"/Unity/Optimization/Unity%20UI%20%E4%BC%98%E5%8C%96.html"},{default:h(()=>s[0]||(s[0]=[a("Best practices: Optimizing Unity UI")])),_:1})]),s[2]||(s[2]=i("li",null,[i("a",{href:"https://docs.unity3d.com/Packages/com.unity.ugui@2.0/manual/index.html",target:"_blank",rel:"noopener noreferrer"},"Unity UI Docs")],-1)),s[3]||(s[3]=i("li",null,[i("a",{href:"https://docs.unity3d.com/cn/current/Manual/ProfilerUI.html",target:"_blank",rel:"noopener noreferrer"},"UI Profiler")],-1)),s[4]||(s[4]=i("li",null,[i("a",{href:"https://www.youtube.com/watch?v=wbmjturGbAQ&list=PLX2vGYjWbI0Rzo8D-vUCFVb_hHGxXWd9j&index=57&t=25s",target:"_blank",rel:"noopener noreferrer"},"Building an easy to use menu system")],-1))])])}const u=t(B,[["render",g]]),v=JSON.parse('{"path":"/Unity/Optimization/Unity%20UI%20%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE.html","title":"Unity UI 优化建议","lang":"zh-CN","frontmatter":{"source":"https://create.unity.com/Unity-UI-optimization-tips","article":false,"index":false},"git":{"createdTime":1744972326000,"updatedTime":1747391455000,"contributors":[{"name":"unknown","username":"unknown","email":"chenmengjie@cyou-inc.com","commits":5,"url":"https://github.com/unknown"},{"name":"chenjie","username":"chenjie","email":"1587272470@qq.com","commits":1,"url":"https://github.com/chenjie"}]},"readingTime":{"minutes":7.13,"words":2140},"filePathRelative":"Unity/Optimization/Unity UI 优化建议.md","localizedDate":"2025年4月18日","excerpt":""}');export{u as comp,v as data};
