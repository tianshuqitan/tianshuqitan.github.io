import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,b as o,a,e as c,w as r,r as d,o as l,d as s}from"./app-C8Xv8B3I.js";const p="/assets/IL2CPP-3-Cy7-s9ix.png",h={};function m(C,e){const t=d("RouteLink");return l(),n("div",null,[e[1]||(e[1]=o('<h1 id="c-技术要点" tabindex="-1"><a class="header-anchor" href="#c-技术要点"><span>C# 技术要点</span></a></h1><h2 id="unity3d-中-c-的底层原理" tabindex="-1"><a class="header-anchor" href="#unity3d-中-c-的底层原理"><span>Unity3D 中 C# 的底层原理</span></a></h2><ul><li><code>.Net Framework</code>：一个基于 Windows 平台的 .Net 开发框架，无法跨平台。</li><li><code>.Net</code>：之前的 .Net Core，一个跨平台、开源的 .NET 实现。</li><li><code>.NET Standard</code>：.Net 标准，是一组规范，为了解决 .NET 生态系统在不同实现（如 .NET Framework、.NET Core 等）之间的兼容性问题。</li><li><code>Mono</code>：一个开源、跨平台的 <code>.Net</code> 实现。</li><li><code>IL/CIL</code>：一种与特定硬件平台和操作系统无关的中间表示形式，C# 源代码不会直接编译为本地机器码，而是先编译成中间语言(IL)。</li><li><code>CLR</code>：<a href="https://learn.microsoft.com/zh-cn/dotnet/standard/clr" target="_blank" rel="noopener noreferrer">CLR</a> 公共语言运行时(Common Language Runtime)。</li><li><code>JIT</code>：即时编译，当 <code>.NET</code> 应用程序启动时，公共语言运行时(CLR)会加载程序集，并将其中的 <code>IL</code> 代码实时编译成本地机器码，这个过程就是即时编译（Just-In-Time Compilation）。JIT 编译器会根据目标平台的特性生成优化后的机器码，以提高执行效率。</li><li><code>AOT</code>：提前编译(Ahead-of-Time Compilation)，它是一种与即时编译(JIT)相对的编译方式，在程序运行之前就将代码编译成本地机器码，而非在运行时进行编译。从 <code>.NET 6</code> 开始，也支持对应用进行 <code>AOT</code> 发布，通过 <code>dotnet publish</code> 命令并指定相应的参数，可以生成 <code>AOT</code> 编译的应用。</li><li><code>IL2CPP</code>：将 IL 代码转换为 C++ 代码。修改版本的 Mono 维护成本大，版权受限，运行效率不高。IL2CPP 有自己的虚拟机，但是不执行 JIT 或者翻译任何代码，只用于内存管理。</li><li><strong>托管代码</strong>：C# 代码生成的 IL 编码我们称为托管代码，由虚拟机的 JIT 编译执行，依赖于 .Net 运行时，其中的对象无须手动释放，它们由 GC 管理。</li><li><strong>非托管代码</strong>：不依赖于 .Net 运行时，C/C++ 或 C# 中以不安全类型写的代码，虚拟机无法跟踪到这类代码对象，需要手动管理内存分配和释放。</li></ul><p><code>IL2CPP</code> 的工作原理</p><ul><li>将 Unity Scripting API 代码编译为常规 <code>.NET DLL</code>（托管程序集）。</li><li>应用托管字节码剥离。此步骤可显著减小构建的游戏大小。</li><li>将所有托管程序集转换为标准 <code>C++</code> 代码。</li><li>使用本机平台编译器编译生成的 <code>C++</code> 代码和 <code>IL2CPP</code> 的运行时部分。</li><li>将代码链接到可执行文件或 DLL，具体取决于目标平台。</li></ul><p><img src="'+p+'" alt=""></p><blockquote><p>使用 IL2CPP 构建项目时所采取的自动步骤的图表</p></blockquote><h2 id="list-源码剖析" tabindex="-1"><a class="header-anchor" href="#list-源码剖析"><span>List 源码剖析</span></a></h2>',8)),a("p",null,[c(t,{to:"/Language/Csharp/SourceCode/SourceCode_List.html"},{default:r(()=>e[0]||(e[0]=[s("List 源码剖析")])),_:1})]),e[2]||(e[2]=o('<h2 id="dictionary-源码剖析" tabindex="-1"><a class="header-anchor" href="#dictionary-源码剖析"><span>Dictionary 源码剖析</span></a></h2><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><ul><li><a href="https://s0nreir.github.io/2022/08/21/Unity%E4%B8%BB%E7%A8%8B%E6%89%8B%E8%AE%B0%E8%AF%BB%E4%B9%A6%E6%91%98%E8%AE%B0_1-2.html" target="_blank" rel="noopener noreferrer">Unity 主程手记记录摘要</a></li></ul>',3))])}const L=i(h,[["render",m]]),B=JSON.parse('{"path":"/Unity/Books/%E4%B8%BB%E7%A8%8B%E6%89%8B%E8%AE%B0/C_%20%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9.html","title":"第二章：C# 技术要点","lang":"zh-CN","frontmatter":{"title":"第二章：C# 技术要点","article":false,"order":2},"git":{"createdTime":1744277214000,"updatedTime":1744277214000,"contributors":[{"name":"unknown","username":"unknown","email":"chenmengjie@cyou-inc.com","commits":1,"url":"https://github.com/unknown"}]},"readingTime":{"minutes":2.4,"words":721},"filePathRelative":"Unity/Books/主程手记/C# 技术要点.md","localizedDate":"2025年4月10日","excerpt":""}');export{L as comp,B as data};
